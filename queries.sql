-- ЗАДАНИЕ 2: АНАЛИТИЧЕСКИЕ SQL-ЗАПРОСЫ

-- 2.1. Получение информации о сумме товаров, заказанных каждым клиентом
-- (Наименование клиента, сумма)

SELECT
    c.name AS client_name,
    SUM(oi.amount) AS total_ordered_amount
FROM
    clients c
JOIN
    orders o ON c.id = o.client_id
JOIN
    order_items oi ON o.id = oi.order_id
-- Можно добавить фильтр по статусу, чтобы считать только завершенные заказы
-- WHERE o.status = 'COMPLETED'
GROUP BY
    c.name
ORDER BY
    total_ordered_amount DESC;

-- 2.2. Найти количество дочерних элементов первого уровня вложенности
-- для всех категорий номенклатуры.
-- Этот запрос посчитает количество прямых потомков для КАЖДОЙ категории в дереве.

SELECT
    parent.name AS category_name,
    COUNT(child.id) AS direct_children_count
FROM
    categories AS parent
-- LEFT JOIN здесь критически важен: он позволяет включить в результат категории,
-- у которых 0 дочерних элементов. INNER JOIN бы их отфильтровал.
LEFT JOIN
    categories AS child ON child.parent_id = parent.id
GROUP BY
    parent.id, parent.name -- Группируем по parent.id для уникальности
ORDER BY
    parent.path; -- Сортируем по ltree path для иерархического вывода


-- ======================================================================================
-- 2.3.1. Текст запроса для отчета (view) «Топ-5 самых покупаемых товаров
-- за последний месяц»
-- ======================================================================================

-- Шаг 1: Создание или обновление самого VIEW.
-- Этот запрос нужно выполнить один раз. Он ничего не возвращает, а только создает объект в БД.
CREATE OR REPLACE VIEW top_5_monthly_products AS
SELECT
    p.name AS product_name,
    -- Находим корневую категорию (уровень 1) с помощью магии ltree
    root_cat.name AS root_category_name,
    SUM(oi.qty) AS total_quantity_sold
FROM
    order_items oi
JOIN
    orders o ON oi.order_id = o.id
JOIN
    products p ON oi.product_id = p.id
JOIN
    categories c ON p.category_id = c.id
-- `root_cat.path @> c.path` означает "путь root_cat является предком пути c"
JOIN
    categories root_cat ON root_cat.path @> c.path AND nlevel(root_cat.path) = 1
WHERE
    o.created_at >= NOW() - INTERVAL '1 month'
    AND o.status IN ('PROCESSING', 'COMPLETED') -- Не считаем отмененные заказы
GROUP BY
    p.name, root_cat.name
ORDER BY
    total_quantity_sold DESC
LIMIT 5;

-- Шаг 2: Получение данных из созданного VIEW.
-- Этот запрос можно выполнять сколько угодно раз, чтобы увидеть актуальный топ-5.
-- SELECT * FROM top_5_monthly_products;


-- ======================================================================================
-- 2.3.2. Анализ и оптимизация запроса
-- ======================================================================================

/*
   АНАЛИЗ ЗАПРОСА И СТРУКТУРЫ БД

   Написанный VIEW-запрос является аналитическим и при росте данных (тысячи заказов в день)
   столкнется с проблемами производительности.

   Слабые места:
   1.  **Большое количество JOIN'ов:** Запрос соединяет 5 таблиц, что является дорогой операцией.
   2.  **Фильтрация по дате по большой таблице:** Условие `WHERE o.created_at >= ...` будет
       применяться к таблице `orders`, которая будет расти быстрее всех. Без индекса это приведет
       к полному сканированию таблицы (Sequential Scan).
   3.  **Агрегация и сортировка:** Операции `GROUP BY`, `SUM` и `ORDER BY` требуют значительных
       вычислительных ресурсов, особенно на больших объемах данных.

   Структура БД в целом хороша: внешние ключи проиндексированы, что ускоряет JOIN'ы. ( в особенности created_at в orders)

   ПРЕДЛОЖЕНИЯ ПО ОПТИМИЗАЦИИ

   Для повышения производительности можно применить следующие подходы в порядке возрастания сложности:

   1.  **Индексирование (Уже сделано):**
       - **Что:** Добавить B-Tree индекс на поле `orders.created_at`.
       - **Зачем:** Это самый важный и простой шаг. Индекс позволяет PostgreSQL мгновенно находить
         заказы за последний месяц, избегая полного сканирования таблицы.
       - **Код:** `CREATE INDEX IF NOT EXISTS idx_orders_created_at ON orders(created_at DESC);`

   2.  **Использование Materialized View (Рекомендуется для отчетов, но ETL круче):**
       - **Что:** Заменить обычный `VIEW` на `MATERIALIZED VIEW`.
       - **Зачем:** В отличие от обычного VIEW, который выполняет тяжелый запрос каждый раз,
         материализованное представление хранит уже вычисленный результат. Запросы к нему
         будут выполняться мгновенно. Это идеальное решение для отчетов, которым не
         требуется актуальность данных в реальном времени.
       - **Как:** Представление можно обновлять по расписанию (например, раз в час)
         командой `REFRESH MATERIALIZED VIEW top_5_monthly_products_mv;`.

   3.  **Денормализация и ETL-процесс (Реализовано в analytics.sql):**
       - **Что:** Создать отдельные аналитические таблицы (витрины данных), например, `daily_product_sales`,
         и наполнять их агрегированными данными по расписанию (ETL-процесс).
       - **Зачем:** Это переносит всю вычислительную нагрузку с операции чтения (SELECT)
         на фоновый процесс. Запрос топа товаров превращается в простейший `SELECT` из
         маленькой, уже посчитанной таблицы, что обеспечивает максимальную скорость.
       - **Как:** Реализовано с помощью таблицы `daily_product_sales` и функции `refresh_daily_sales`,
         которую вызывает периодический сервис `etl-cron` в Docker.
*/

-- Благодаря Денормализация и ETL-процесс у нас новый, молниеносный запрос для "Топ-5 за последний месяц",
-- использующий предварительно агрегированные данные из витрины.
-- данные отличаются потому что он берет данные за вчерашний день
SELECT
    p.name AS product_name,
    -- Мы больше не соединяем 5 таблиц, а берем готовые данные
    SUM(dps.total_qty_sold) AS total_quantity
FROM
    daily_product_sales dps
JOIN
    products p ON dps.product_id = p.id
WHERE
    dps.sale_date >= CURRENT_DATE - INTERVAL '1 month'
GROUP BY
    p.name
ORDER BY
    total_quantity DESC
LIMIT 5;